// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.23.0-devel
// 	protoc        v3.12.0
// source: nlp.proto

package nlp

import (
	context "context"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

type TextRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Text string `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
}

func (x *TextRequest) Reset() {
	*x = TextRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_nlp_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TextRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TextRequest) ProtoMessage() {}

func (x *TextRequest) ProtoReflect() protoreflect.Message {
	mi := &file_nlp_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TextRequest.ProtoReflect.Descriptor instead.
func (*TextRequest) Descriptor() ([]byte, []int) {
	return file_nlp_proto_rawDescGZIP(), []int{0}
}

func (x *TextRequest) GetText() string {
	if x != nil {
		return x.Text
	}
	return ""
}

type TextSimilarityRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Texta string `protobuf:"bytes,1,opt,name=texta,proto3" json:"texta,omitempty"`
	Textb string `protobuf:"bytes,2,opt,name=textb,proto3" json:"textb,omitempty"`
}

func (x *TextSimilarityRequest) Reset() {
	*x = TextSimilarityRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_nlp_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TextSimilarityRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TextSimilarityRequest) ProtoMessage() {}

func (x *TextSimilarityRequest) ProtoReflect() protoreflect.Message {
	mi := &file_nlp_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TextSimilarityRequest.ProtoReflect.Descriptor instead.
func (*TextSimilarityRequest) Descriptor() ([]byte, []int) {
	return file_nlp_proto_rawDescGZIP(), []int{1}
}

func (x *TextSimilarityRequest) GetTexta() string {
	if x != nil {
		return x.Texta
	}
	return ""
}

func (x *TextSimilarityRequest) GetTextb() string {
	if x != nil {
		return x.Textb
	}
	return ""
}

type TextResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
}

func (x *TextResponse) Reset() {
	*x = TextResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_nlp_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TextResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TextResponse) ProtoMessage() {}

func (x *TextResponse) ProtoReflect() protoreflect.Message {
	mi := &file_nlp_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TextResponse.ProtoReflect.Descriptor instead.
func (*TextResponse) Descriptor() ([]byte, []int) {
	return file_nlp_proto_rawDescGZIP(), []int{2}
}

func (x *TextResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

type TextSimilarity struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Similarity float32 `protobuf:"fixed32,1,opt,name=similarity,proto3" json:"similarity,omitempty"`
}

func (x *TextSimilarity) Reset() {
	*x = TextSimilarity{}
	if protoimpl.UnsafeEnabled {
		mi := &file_nlp_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TextSimilarity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TextSimilarity) ProtoMessage() {}

func (x *TextSimilarity) ProtoReflect() protoreflect.Message {
	mi := &file_nlp_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TextSimilarity.ProtoReflect.Descriptor instead.
func (*TextSimilarity) Descriptor() ([]byte, []int) {
	return file_nlp_proto_rawDescGZIP(), []int{3}
}

func (x *TextSimilarity) GetSimilarity() float32 {
	if x != nil {
		return x.Similarity
	}
	return 0
}

type Doc struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Text        string `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	TextWithWs  string `protobuf:"bytes,2,opt,name=text_with_ws,json=textWithWs,proto3" json:"text_with_ws,omitempty"`
	IsTagged    bool   `protobuf:"varint,3,opt,name=is_tagged,json=isTagged,proto3" json:"is_tagged,omitempty"`
	IsParsed    bool   `protobuf:"varint,4,opt,name=is_parsed,json=isParsed,proto3" json:"is_parsed,omitempty"`
	IsNered     bool   `protobuf:"varint,5,opt,name=is_nered,json=isNered,proto3" json:"is_nered,omitempty"`
	IsSentenced bool   `protobuf:"varint,6,opt,name=is_sentenced,json=isSentenced,proto3" json:"is_sentenced,omitempty"`
}

func (x *Doc) Reset() {
	*x = Doc{}
	if protoimpl.UnsafeEnabled {
		mi := &file_nlp_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Doc) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Doc) ProtoMessage() {}

func (x *Doc) ProtoReflect() protoreflect.Message {
	mi := &file_nlp_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Doc.ProtoReflect.Descriptor instead.
func (*Doc) Descriptor() ([]byte, []int) {
	return file_nlp_proto_rawDescGZIP(), []int{4}
}

func (x *Doc) GetText() string {
	if x != nil {
		return x.Text
	}
	return ""
}

func (x *Doc) GetTextWithWs() string {
	if x != nil {
		return x.TextWithWs
	}
	return ""
}

func (x *Doc) GetIsTagged() bool {
	if x != nil {
		return x.IsTagged
	}
	return false
}

func (x *Doc) GetIsParsed() bool {
	if x != nil {
		return x.IsParsed
	}
	return false
}

func (x *Doc) GetIsNered() bool {
	if x != nil {
		return x.IsNered
	}
	return false
}

func (x *Doc) GetIsSentenced() bool {
	if x != nil {
		return x.IsSentenced
	}
	return false
}

type Ent struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Start int32  `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	End   int32  `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	Label string `protobuf:"bytes,3,opt,name=label,proto3" json:"label,omitempty"`
}

func (x *Ent) Reset() {
	*x = Ent{}
	if protoimpl.UnsafeEnabled {
		mi := &file_nlp_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Ent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Ent) ProtoMessage() {}

func (x *Ent) ProtoReflect() protoreflect.Message {
	mi := &file_nlp_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Ent.ProtoReflect.Descriptor instead.
func (*Ent) Descriptor() ([]byte, []int) {
	return file_nlp_proto_rawDescGZIP(), []int{5}
}

func (x *Ent) GetStart() int32 {
	if x != nil {
		return x.Start
	}
	return 0
}

func (x *Ent) GetEnd() int32 {
	if x != nil {
		return x.End
	}
	return 0
}

func (x *Ent) GetLabel() string {
	if x != nil {
		return x.Label
	}
	return ""
}

type Sent struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Start int32 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	End   int32 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (x *Sent) Reset() {
	*x = Sent{}
	if protoimpl.UnsafeEnabled {
		mi := &file_nlp_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Sent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Sent) ProtoMessage() {}

func (x *Sent) ProtoReflect() protoreflect.Message {
	mi := &file_nlp_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Sent.ProtoReflect.Descriptor instead.
func (*Sent) Descriptor() ([]byte, []int) {
	return file_nlp_proto_rawDescGZIP(), []int{6}
}

func (x *Sent) GetStart() int32 {
	if x != nil {
		return x.Start
	}
	return 0
}

func (x *Sent) GetEnd() int32 {
	if x != nil {
		return x.End
	}
	return 0
}

type NounChunk struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Start int32 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	End   int32 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (x *NounChunk) Reset() {
	*x = NounChunk{}
	if protoimpl.UnsafeEnabled {
		mi := &file_nlp_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NounChunk) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NounChunk) ProtoMessage() {}

func (x *NounChunk) ProtoReflect() protoreflect.Message {
	mi := &file_nlp_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NounChunk.ProtoReflect.Descriptor instead.
func (*NounChunk) Descriptor() ([]byte, []int) {
	return file_nlp_proto_rawDescGZIP(), []int{7}
}

func (x *NounChunk) GetStart() int32 {
	if x != nil {
		return x.Start
	}
	return 0
}

func (x *NounChunk) GetEnd() int32 {
	if x != nil {
		return x.End
	}
	return 0
}

type Token struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Text         string `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	TextWithWs   string `protobuf:"bytes,2,opt,name=text_with_ws,json=textWithWs,proto3" json:"text_with_ws,omitempty"`
	Whitespace   string `protobuf:"bytes,3,opt,name=whitespace,proto3" json:"whitespace,omitempty"`
	EntType      string `protobuf:"bytes,5,opt,name=ent_type,json=entType,proto3" json:"ent_type,omitempty"`
	EntIob       string `protobuf:"bytes,6,opt,name=ent_iob,json=entIob,proto3" json:"ent_iob,omitempty"`
	Lemma        string `protobuf:"bytes,7,opt,name=lemma,proto3" json:"lemma,omitempty"`
	Norm         string `protobuf:"bytes,8,opt,name=norm,proto3" json:"norm,omitempty"`
	Lower        string `protobuf:"bytes,9,opt,name=lower,proto3" json:"lower,omitempty"`
	Shape        string `protobuf:"bytes,10,opt,name=shape,proto3" json:"shape,omitempty"`
	Prefix       string `protobuf:"bytes,11,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Suffix       string `protobuf:"bytes,12,opt,name=suffix,proto3" json:"suffix,omitempty"`
	Pos          string `protobuf:"bytes,13,opt,name=pos,proto3" json:"pos,omitempty"`
	Tag          string `protobuf:"bytes,14,opt,name=tag,proto3" json:"tag,omitempty"`
	Dep          string `protobuf:"bytes,15,opt,name=dep,proto3" json:"dep,omitempty"`
	IsAlpha      bool   `protobuf:"varint,16,opt,name=is_alpha,json=isAlpha,proto3" json:"is_alpha,omitempty"`
	IsAscii      bool   `protobuf:"varint,17,opt,name=is_ascii,json=isAscii,proto3" json:"is_ascii,omitempty"`
	IsDigit      bool   `protobuf:"varint,18,opt,name=is_digit,json=isDigit,proto3" json:"is_digit,omitempty"`
	IsLower      bool   `protobuf:"varint,19,opt,name=is_lower,json=isLower,proto3" json:"is_lower,omitempty"`
	IsUpper      bool   `protobuf:"varint,20,opt,name=is_upper,json=isUpper,proto3" json:"is_upper,omitempty"`
	IsTitle      bool   `protobuf:"varint,21,opt,name=is_title,json=isTitle,proto3" json:"is_title,omitempty"`
	IsPunct      bool   `protobuf:"varint,22,opt,name=is_punct,json=isPunct,proto3" json:"is_punct,omitempty"`
	IsLeftPunct  bool   `protobuf:"varint,23,opt,name=is_left_punct,json=isLeftPunct,proto3" json:"is_left_punct,omitempty"`
	IsRightPunct bool   `protobuf:"varint,24,opt,name=is_right_punct,json=isRightPunct,proto3" json:"is_right_punct,omitempty"`
	IsSpace      bool   `protobuf:"varint,25,opt,name=is_space,json=isSpace,proto3" json:"is_space,omitempty"`
	IsBracket    bool   `protobuf:"varint,26,opt,name=is_bracket,json=isBracket,proto3" json:"is_bracket,omitempty"`
	IsCurrency   bool   `protobuf:"varint,27,opt,name=is_currency,json=isCurrency,proto3" json:"is_currency,omitempty"`
	LikeUrl      bool   `protobuf:"varint,28,opt,name=like_url,json=likeUrl,proto3" json:"like_url,omitempty"`
	LikeNum      bool   `protobuf:"varint,29,opt,name=like_num,json=likeNum,proto3" json:"like_num,omitempty"`
	LikeEmail    bool   `protobuf:"varint,30,opt,name=like_email,json=likeEmail,proto3" json:"like_email,omitempty"`
	IsOov        bool   `protobuf:"varint,31,opt,name=is_oov,json=isOov,proto3" json:"is_oov,omitempty"`
	IsStop       bool   `protobuf:"varint,32,opt,name=is_stop,json=isStop,proto3" json:"is_stop,omitempty"`
	IsSentStart  bool   `protobuf:"varint,33,opt,name=is_sent_start,json=isSentStart,proto3" json:"is_sent_start,omitempty"`
	Head         int32  `protobuf:"varint,34,opt,name=head,proto3" json:"head,omitempty"`
}

func (x *Token) Reset() {
	*x = Token{}
	if protoimpl.UnsafeEnabled {
		mi := &file_nlp_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Token) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Token) ProtoMessage() {}

func (x *Token) ProtoReflect() protoreflect.Message {
	mi := &file_nlp_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Token.ProtoReflect.Descriptor instead.
func (*Token) Descriptor() ([]byte, []int) {
	return file_nlp_proto_rawDescGZIP(), []int{8}
}

func (x *Token) GetText() string {
	if x != nil {
		return x.Text
	}
	return ""
}

func (x *Token) GetTextWithWs() string {
	if x != nil {
		return x.TextWithWs
	}
	return ""
}

func (x *Token) GetWhitespace() string {
	if x != nil {
		return x.Whitespace
	}
	return ""
}

func (x *Token) GetEntType() string {
	if x != nil {
		return x.EntType
	}
	return ""
}

func (x *Token) GetEntIob() string {
	if x != nil {
		return x.EntIob
	}
	return ""
}

func (x *Token) GetLemma() string {
	if x != nil {
		return x.Lemma
	}
	return ""
}

func (x *Token) GetNorm() string {
	if x != nil {
		return x.Norm
	}
	return ""
}

func (x *Token) GetLower() string {
	if x != nil {
		return x.Lower
	}
	return ""
}

func (x *Token) GetShape() string {
	if x != nil {
		return x.Shape
	}
	return ""
}

func (x *Token) GetPrefix() string {
	if x != nil {
		return x.Prefix
	}
	return ""
}

func (x *Token) GetSuffix() string {
	if x != nil {
		return x.Suffix
	}
	return ""
}

func (x *Token) GetPos() string {
	if x != nil {
		return x.Pos
	}
	return ""
}

func (x *Token) GetTag() string {
	if x != nil {
		return x.Tag
	}
	return ""
}

func (x *Token) GetDep() string {
	if x != nil {
		return x.Dep
	}
	return ""
}

func (x *Token) GetIsAlpha() bool {
	if x != nil {
		return x.IsAlpha
	}
	return false
}

func (x *Token) GetIsAscii() bool {
	if x != nil {
		return x.IsAscii
	}
	return false
}

func (x *Token) GetIsDigit() bool {
	if x != nil {
		return x.IsDigit
	}
	return false
}

func (x *Token) GetIsLower() bool {
	if x != nil {
		return x.IsLower
	}
	return false
}

func (x *Token) GetIsUpper() bool {
	if x != nil {
		return x.IsUpper
	}
	return false
}

func (x *Token) GetIsTitle() bool {
	if x != nil {
		return x.IsTitle
	}
	return false
}

func (x *Token) GetIsPunct() bool {
	if x != nil {
		return x.IsPunct
	}
	return false
}

func (x *Token) GetIsLeftPunct() bool {
	if x != nil {
		return x.IsLeftPunct
	}
	return false
}

func (x *Token) GetIsRightPunct() bool {
	if x != nil {
		return x.IsRightPunct
	}
	return false
}

func (x *Token) GetIsSpace() bool {
	if x != nil {
		return x.IsSpace
	}
	return false
}

func (x *Token) GetIsBracket() bool {
	if x != nil {
		return x.IsBracket
	}
	return false
}

func (x *Token) GetIsCurrency() bool {
	if x != nil {
		return x.IsCurrency
	}
	return false
}

func (x *Token) GetLikeUrl() bool {
	if x != nil {
		return x.LikeUrl
	}
	return false
}

func (x *Token) GetLikeNum() bool {
	if x != nil {
		return x.LikeNum
	}
	return false
}

func (x *Token) GetLikeEmail() bool {
	if x != nil {
		return x.LikeEmail
	}
	return false
}

func (x *Token) GetIsOov() bool {
	if x != nil {
		return x.IsOov
	}
	return false
}

func (x *Token) GetIsStop() bool {
	if x != nil {
		return x.IsStop
	}
	return false
}

func (x *Token) GetIsSentStart() bool {
	if x != nil {
		return x.IsSentStart
	}
	return false
}

func (x *Token) GetHead() int32 {
	if x != nil {
		return x.Head
	}
	return 0
}

type ParsedNLPRes struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Model      string       `protobuf:"bytes,1,opt,name=model,proto3" json:"model,omitempty"`
	Doc        *Doc         `protobuf:"bytes,2,opt,name=doc,proto3" json:"doc,omitempty"`
	Ents       []*Ent       `protobuf:"bytes,3,rep,name=ents,proto3" json:"ents,omitempty"`
	Sents      []*Sent      `protobuf:"bytes,4,rep,name=sents,proto3" json:"sents,omitempty"`
	NounChunks []*NounChunk `protobuf:"bytes,5,rep,name=noun_chunks,json=nounChunks,proto3" json:"noun_chunks,omitempty"`
	Tokens     []*Token     `protobuf:"bytes,6,rep,name=tokens,proto3" json:"tokens,omitempty"`
}

func (x *ParsedNLPRes) Reset() {
	*x = ParsedNLPRes{}
	if protoimpl.UnsafeEnabled {
		mi := &file_nlp_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ParsedNLPRes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ParsedNLPRes) ProtoMessage() {}

func (x *ParsedNLPRes) ProtoReflect() protoreflect.Message {
	mi := &file_nlp_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ParsedNLPRes.ProtoReflect.Descriptor instead.
func (*ParsedNLPRes) Descriptor() ([]byte, []int) {
	return file_nlp_proto_rawDescGZIP(), []int{9}
}

func (x *ParsedNLPRes) GetModel() string {
	if x != nil {
		return x.Model
	}
	return ""
}

func (x *ParsedNLPRes) GetDoc() *Doc {
	if x != nil {
		return x.Doc
	}
	return nil
}

func (x *ParsedNLPRes) GetEnts() []*Ent {
	if x != nil {
		return x.Ents
	}
	return nil
}

func (x *ParsedNLPRes) GetSents() []*Sent {
	if x != nil {
		return x.Sents
	}
	return nil
}

func (x *ParsedNLPRes) GetNounChunks() []*NounChunk {
	if x != nil {
		return x.NounChunks
	}
	return nil
}

func (x *ParsedNLPRes) GetTokens() []*Token {
	if x != nil {
		return x.Tokens
	}
	return nil
}

type Pattern struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (x *Pattern) Reset() {
	*x = Pattern{}
	if protoimpl.UnsafeEnabled {
		mi := &file_nlp_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Pattern) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Pattern) ProtoMessage() {}

func (x *Pattern) ProtoReflect() protoreflect.Message {
	mi := &file_nlp_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Pattern.ProtoReflect.Descriptor instead.
func (*Pattern) Descriptor() ([]byte, []int) {
	return file_nlp_proto_rawDescGZIP(), []int{10}
}

func (x *Pattern) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *Pattern) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

type Rule struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id       string     `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Patterns []*Pattern `protobuf:"bytes,2,rep,name=patterns,proto3" json:"patterns,omitempty"`
}

func (x *Rule) Reset() {
	*x = Rule{}
	if protoimpl.UnsafeEnabled {
		mi := &file_nlp_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Rule) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Rule) ProtoMessage() {}

func (x *Rule) ProtoReflect() protoreflect.Message {
	mi := &file_nlp_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Rule.ProtoReflect.Descriptor instead.
func (*Rule) Descriptor() ([]byte, []int) {
	return file_nlp_proto_rawDescGZIP(), []int{11}
}

func (x *Rule) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Rule) GetPatterns() []*Pattern {
	if x != nil {
		return x.Patterns
	}
	return nil
}

type Match struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Id    string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Start int32  `protobuf:"varint,2,opt,name=start,proto3" json:"start,omitempty"`
	End   int32  `protobuf:"varint,3,opt,name=end,proto3" json:"end,omitempty"`
}

func (x *Match) Reset() {
	*x = Match{}
	if protoimpl.UnsafeEnabled {
		mi := &file_nlp_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Match) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Match) ProtoMessage() {}

func (x *Match) ProtoReflect() protoreflect.Message {
	mi := &file_nlp_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Match.ProtoReflect.Descriptor instead.
func (*Match) Descriptor() ([]byte, []int) {
	return file_nlp_proto_rawDescGZIP(), []int{12}
}

func (x *Match) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Match) GetStart() int32 {
	if x != nil {
		return x.Start
	}
	return 0
}

func (x *Match) GetEnd() int32 {
	if x != nil {
		return x.End
	}
	return 0
}

type Matches struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Matches []*Match `protobuf:"bytes,1,rep,name=matches,proto3" json:"matches,omitempty"`
}

func (x *Matches) Reset() {
	*x = Matches{}
	if protoimpl.UnsafeEnabled {
		mi := &file_nlp_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Matches) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Matches) ProtoMessage() {}

func (x *Matches) ProtoReflect() protoreflect.Message {
	mi := &file_nlp_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Matches.ProtoReflect.Descriptor instead.
func (*Matches) Descriptor() ([]byte, []int) {
	return file_nlp_proto_rawDescGZIP(), []int{13}
}

func (x *Matches) GetMatches() []*Match {
	if x != nil {
		return x.Matches
	}
	return nil
}

var File_nlp_proto protoreflect.FileDescriptor

var file_nlp_proto_rawDesc = []byte{
	0x0a, 0x09, 0x6e, 0x6c, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x03, 0x6e, 0x6c, 0x70,
	0x22, 0x21, 0x0a, 0x0b, 0x54, 0x65, 0x78, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
	0x12, 0x0a, 0x04, 0x74, 0x65, 0x78, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x74,
	0x65, 0x78, 0x74, 0x22, 0x43, 0x0a, 0x15, 0x54, 0x65, 0x78, 0x74, 0x53, 0x69, 0x6d, 0x69, 0x6c,
	0x61, 0x72, 0x69, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x05,
	0x74, 0x65, 0x78, 0x74, 0x61, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x74, 0x65, 0x78,
	0x74, 0x61, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x65, 0x78, 0x74, 0x62, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x05, 0x74, 0x65, 0x78, 0x74, 0x62, 0x22, 0x28, 0x0a, 0x0c, 0x54, 0x65, 0x78, 0x74,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73,
	0x61, 0x67, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61,
	0x67, 0x65, 0x22, 0x30, 0x0a, 0x0e, 0x54, 0x65, 0x78, 0x74, 0x53, 0x69, 0x6d, 0x69, 0x6c, 0x61,
	0x72, 0x69, 0x74, 0x79, 0x12, 0x1e, 0x0a, 0x0a, 0x73, 0x69, 0x6d, 0x69, 0x6c, 0x61, 0x72, 0x69,
	0x74, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0a, 0x73, 0x69, 0x6d, 0x69, 0x6c, 0x61,
	0x72, 0x69, 0x74, 0x79, 0x22, 0xb3, 0x01, 0x0a, 0x03, 0x44, 0x6f, 0x63, 0x12, 0x12, 0x0a, 0x04,
	0x74, 0x65, 0x78, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x74, 0x65, 0x78, 0x74,
	0x12, 0x20, 0x0a, 0x0c, 0x74, 0x65, 0x78, 0x74, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x77, 0x73,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x74, 0x65, 0x78, 0x74, 0x57, 0x69, 0x74, 0x68,
	0x57, 0x73, 0x12, 0x1b, 0x0a, 0x09, 0x69, 0x73, 0x5f, 0x74, 0x61, 0x67, 0x67, 0x65, 0x64, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x69, 0x73, 0x54, 0x61, 0x67, 0x67, 0x65, 0x64, 0x12,
	0x1b, 0x0a, 0x09, 0x69, 0x73, 0x5f, 0x70, 0x61, 0x72, 0x73, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x08, 0x69, 0x73, 0x50, 0x61, 0x72, 0x73, 0x65, 0x64, 0x12, 0x19, 0x0a, 0x08,
	0x69, 0x73, 0x5f, 0x6e, 0x65, 0x72, 0x65, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07,
	0x69, 0x73, 0x4e, 0x65, 0x72, 0x65, 0x64, 0x12, 0x21, 0x0a, 0x0c, 0x69, 0x73, 0x5f, 0x73, 0x65,
	0x6e, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x69,
	0x73, 0x53, 0x65, 0x6e, 0x74, 0x65, 0x6e, 0x63, 0x65, 0x64, 0x22, 0x43, 0x0a, 0x03, 0x45, 0x6e,
	0x74, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05,
	0x52, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x65, 0x6e, 0x64, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x65, 0x6e, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x61, 0x62,
	0x65, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x22,
	0x2e, 0x0a, 0x04, 0x53, 0x65, 0x6e, 0x74, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x12, 0x10, 0x0a,
	0x03, 0x65, 0x6e, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x65, 0x6e, 0x64, 0x22,
	0x34, 0x0a, 0x0a, 0x4e, 0x6f, 0x75, 0x6e, 0x5f, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x12, 0x14, 0x0a,
	0x05, 0x73, 0x74, 0x61, 0x72, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x73, 0x74,
	0x61, 0x72, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x65, 0x6e, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05,
	0x52, 0x03, 0x65, 0x6e, 0x64, 0x22, 0xec, 0x06, 0x0a, 0x05, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12,
	0x12, 0x0a, 0x04, 0x74, 0x65, 0x78, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x74,
	0x65, 0x78, 0x74, 0x12, 0x20, 0x0a, 0x0c, 0x74, 0x65, 0x78, 0x74, 0x5f, 0x77, 0x69, 0x74, 0x68,
	0x5f, 0x77, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x74, 0x65, 0x78, 0x74, 0x57,
	0x69, 0x74, 0x68, 0x57, 0x73, 0x12, 0x1e, 0x0a, 0x0a, 0x77, 0x68, 0x69, 0x74, 0x65, 0x73, 0x70,
	0x61, 0x63, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x77, 0x68, 0x69, 0x74, 0x65,
	0x73, 0x70, 0x61, 0x63, 0x65, 0x12, 0x19, 0x0a, 0x08, 0x65, 0x6e, 0x74, 0x5f, 0x74, 0x79, 0x70,
	0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x65, 0x6e, 0x74, 0x54, 0x79, 0x70, 0x65,
	0x12, 0x17, 0x0a, 0x07, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x6f, 0x62, 0x18, 0x06, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x06, 0x65, 0x6e, 0x74, 0x49, 0x6f, 0x62, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x65, 0x6d,
	0x6d, 0x61, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6c, 0x65, 0x6d, 0x6d, 0x61, 0x12,
	0x12, 0x0a, 0x04, 0x6e, 0x6f, 0x72, 0x6d, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e,
	0x6f, 0x72, 0x6d, 0x12, 0x14, 0x0a, 0x05, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x18, 0x09, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x05, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x68, 0x61,
	0x70, 0x65, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x73, 0x68, 0x61, 0x70, 0x65, 0x12,
	0x16, 0x0a, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x75, 0x66, 0x66, 0x69,
	0x78, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x75, 0x66, 0x66, 0x69, 0x78, 0x12,
	0x10, 0x0a, 0x03, 0x70, 0x6f, 0x73, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x70, 0x6f,
	0x73, 0x12, 0x10, 0x0a, 0x03, 0x74, 0x61, 0x67, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03,
	0x74, 0x61, 0x67, 0x12, 0x10, 0x0a, 0x03, 0x64, 0x65, 0x70, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x03, 0x64, 0x65, 0x70, 0x12, 0x19, 0x0a, 0x08, 0x69, 0x73, 0x5f, 0x61, 0x6c, 0x70, 0x68,
	0x61, 0x18, 0x10, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x69, 0x73, 0x41, 0x6c, 0x70, 0x68, 0x61,
	0x12, 0x19, 0x0a, 0x08, 0x69, 0x73, 0x5f, 0x61, 0x73, 0x63, 0x69, 0x69, 0x18, 0x11, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x07, 0x69, 0x73, 0x41, 0x73, 0x63, 0x69, 0x69, 0x12, 0x19, 0x0a, 0x08, 0x69,
	0x73, 0x5f, 0x64, 0x69, 0x67, 0x69, 0x74, 0x18, 0x12, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x69,
	0x73, 0x44, 0x69, 0x67, 0x69, 0x74, 0x12, 0x19, 0x0a, 0x08, 0x69, 0x73, 0x5f, 0x6c, 0x6f, 0x77,
	0x65, 0x72, 0x18, 0x13, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x69, 0x73, 0x4c, 0x6f, 0x77, 0x65,
	0x72, 0x12, 0x19, 0x0a, 0x08, 0x69, 0x73, 0x5f, 0x75, 0x70, 0x70, 0x65, 0x72, 0x18, 0x14, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x07, 0x69, 0x73, 0x55, 0x70, 0x70, 0x65, 0x72, 0x12, 0x19, 0x0a, 0x08,
	0x69, 0x73, 0x5f, 0x74, 0x69, 0x74, 0x6c, 0x65, 0x18, 0x15, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07,
	0x69, 0x73, 0x54, 0x69, 0x74, 0x6c, 0x65, 0x12, 0x19, 0x0a, 0x08, 0x69, 0x73, 0x5f, 0x70, 0x75,
	0x6e, 0x63, 0x74, 0x18, 0x16, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x69, 0x73, 0x50, 0x75, 0x6e,
	0x63, 0x74, 0x12, 0x22, 0x0a, 0x0d, 0x69, 0x73, 0x5f, 0x6c, 0x65, 0x66, 0x74, 0x5f, 0x70, 0x75,
	0x6e, 0x63, 0x74, 0x18, 0x17, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0b, 0x69, 0x73, 0x4c, 0x65, 0x66,
	0x74, 0x50, 0x75, 0x6e, 0x63, 0x74, 0x12, 0x24, 0x0a, 0x0e, 0x69, 0x73, 0x5f, 0x72, 0x69, 0x67,
	0x68, 0x74, 0x5f, 0x70, 0x75, 0x6e, 0x63, 0x74, 0x18, 0x18, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0c,
	0x69, 0x73, 0x52, 0x69, 0x67, 0x68, 0x74, 0x50, 0x75, 0x6e, 0x63, 0x74, 0x12, 0x19, 0x0a, 0x08,
	0x69, 0x73, 0x5f, 0x73, 0x70, 0x61, 0x63, 0x65, 0x18, 0x19, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07,
	0x69, 0x73, 0x53, 0x70, 0x61, 0x63, 0x65, 0x12, 0x1d, 0x0a, 0x0a, 0x69, 0x73, 0x5f, 0x62, 0x72,
	0x61, 0x63, 0x6b, 0x65, 0x74, 0x18, 0x1a, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x69, 0x73, 0x42,
	0x72, 0x61, 0x63, 0x6b, 0x65, 0x74, 0x12, 0x1f, 0x0a, 0x0b, 0x69, 0x73, 0x5f, 0x63, 0x75, 0x72,
	0x72, 0x65, 0x6e, 0x63, 0x79, 0x18, 0x1b, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x69, 0x73, 0x43,
	0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x12, 0x19, 0x0a, 0x08, 0x6c, 0x69, 0x6b, 0x65, 0x5f,
	0x75, 0x72, 0x6c, 0x18, 0x1c, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x6c, 0x69, 0x6b, 0x65, 0x55,
	0x72, 0x6c, 0x12, 0x19, 0x0a, 0x08, 0x6c, 0x69, 0x6b, 0x65, 0x5f, 0x6e, 0x75, 0x6d, 0x18, 0x1d,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x6c, 0x69, 0x6b, 0x65, 0x4e, 0x75, 0x6d, 0x12, 0x1d, 0x0a,
	0x0a, 0x6c, 0x69, 0x6b, 0x65, 0x5f, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x18, 0x1e, 0x20, 0x01, 0x28,
	0x08, 0x52, 0x09, 0x6c, 0x69, 0x6b, 0x65, 0x45, 0x6d, 0x61, 0x69, 0x6c, 0x12, 0x15, 0x0a, 0x06,
	0x69, 0x73, 0x5f, 0x6f, 0x6f, 0x76, 0x18, 0x1f, 0x20, 0x01, 0x28, 0x08, 0x52, 0x05, 0x69, 0x73,
	0x4f, 0x6f, 0x76, 0x12, 0x17, 0x0a, 0x07, 0x69, 0x73, 0x5f, 0x73, 0x74, 0x6f, 0x70, 0x18, 0x20,
	0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x69, 0x73, 0x53, 0x74, 0x6f, 0x70, 0x12, 0x22, 0x0a, 0x0d,
	0x69, 0x73, 0x5f, 0x73, 0x65, 0x6e, 0x74, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x74, 0x18, 0x21, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x0b, 0x69, 0x73, 0x53, 0x65, 0x6e, 0x74, 0x53, 0x74, 0x61, 0x72, 0x74,
	0x12, 0x12, 0x0a, 0x04, 0x68, 0x65, 0x61, 0x64, 0x18, 0x22, 0x20, 0x01, 0x28, 0x05, 0x52, 0x04,
	0x68, 0x65, 0x61, 0x64, 0x22, 0xd5, 0x01, 0x0a, 0x0c, 0x50, 0x61, 0x72, 0x73, 0x65, 0x64, 0x4e,
	0x4c, 0x50, 0x52, 0x65, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x12, 0x1a, 0x0a, 0x03, 0x64,
	0x6f, 0x63, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x08, 0x2e, 0x6e, 0x6c, 0x70, 0x2e, 0x44,
	0x6f, 0x63, 0x52, 0x03, 0x64, 0x6f, 0x63, 0x12, 0x1c, 0x0a, 0x04, 0x65, 0x6e, 0x74, 0x73, 0x18,
	0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x08, 0x2e, 0x6e, 0x6c, 0x70, 0x2e, 0x45, 0x6e, 0x74, 0x52,
	0x04, 0x65, 0x6e, 0x74, 0x73, 0x12, 0x1f, 0x0a, 0x05, 0x73, 0x65, 0x6e, 0x74, 0x73, 0x18, 0x04,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x09, 0x2e, 0x6e, 0x6c, 0x70, 0x2e, 0x53, 0x65, 0x6e, 0x74, 0x52,
	0x05, 0x73, 0x65, 0x6e, 0x74, 0x73, 0x12, 0x30, 0x0a, 0x0b, 0x6e, 0x6f, 0x75, 0x6e, 0x5f, 0x63,
	0x68, 0x75, 0x6e, 0x6b, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x6e, 0x6c,
	0x70, 0x2e, 0x4e, 0x6f, 0x75, 0x6e, 0x5f, 0x63, 0x68, 0x75, 0x6e, 0x6b, 0x52, 0x0a, 0x6e, 0x6f,
	0x75, 0x6e, 0x43, 0x68, 0x75, 0x6e, 0x6b, 0x73, 0x12, 0x22, 0x0a, 0x06, 0x74, 0x6f, 0x6b, 0x65,
	0x6e, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0a, 0x2e, 0x6e, 0x6c, 0x70, 0x2e, 0x54,
	0x6f, 0x6b, 0x65, 0x6e, 0x52, 0x06, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x22, 0x31, 0x0a, 0x07,
	0x50, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c,
	0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22,
	0x40, 0x0a, 0x04, 0x52, 0x75, 0x6c, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x28, 0x0a, 0x08, 0x70, 0x61, 0x74, 0x74, 0x65,
	0x72, 0x6e, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x6e, 0x6c, 0x70, 0x2e,
	0x50, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x52, 0x08, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e,
	0x73, 0x22, 0x3f, 0x0a, 0x05, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x69, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x73, 0x74,
	0x61, 0x72, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x73, 0x74, 0x61, 0x72, 0x74,
	0x12, 0x10, 0x0a, 0x03, 0x65, 0x6e, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x03, 0x65,
	0x6e, 0x64, 0x22, 0x2f, 0x0a, 0x07, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x12, 0x24, 0x0a,
	0x07, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0a,
	0x2e, 0x6e, 0x6c, 0x70, 0x2e, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x52, 0x07, 0x6d, 0x61, 0x74, 0x63,
	0x68, 0x65, 0x73, 0x32, 0xa3, 0x03, 0x0a, 0x03, 0x4e, 0x6c, 0x70, 0x12, 0x32, 0x0a, 0x09, 0x4c,
	0x6f, 0x61, 0x64, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x12, 0x10, 0x2e, 0x6e, 0x6c, 0x70, 0x2e, 0x54,
	0x65, 0x78, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x11, 0x2e, 0x6e, 0x6c, 0x70,
	0x2e, 0x54, 0x65, 0x78, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12,
	0x33, 0x0a, 0x0a, 0x4e, 0x6c, 0x70, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x12, 0x10, 0x2e,
	0x6e, 0x6c, 0x70, 0x2e, 0x54, 0x65, 0x78, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a,
	0x11, 0x2e, 0x6e, 0x6c, 0x70, 0x2e, 0x50, 0x61, 0x72, 0x73, 0x65, 0x64, 0x4e, 0x4c, 0x50, 0x52,
	0x65, 0x73, 0x22, 0x00, 0x12, 0x42, 0x0a, 0x0d, 0x44, 0x6f, 0x63, 0x53, 0x69, 0x6d, 0x69, 0x6c,
	0x61, 0x72, 0x69, 0x74, 0x79, 0x12, 0x1a, 0x2e, 0x6e, 0x6c, 0x70, 0x2e, 0x54, 0x65, 0x78, 0x74,
	0x53, 0x69, 0x6d, 0x69, 0x6c, 0x61, 0x72, 0x69, 0x74, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x1a, 0x13, 0x2e, 0x6e, 0x6c, 0x70, 0x2e, 0x54, 0x65, 0x78, 0x74, 0x53, 0x69, 0x6d, 0x69,
	0x6c, 0x61, 0x72, 0x69, 0x74, 0x79, 0x22, 0x00, 0x12, 0x29, 0x0a, 0x07, 0x41, 0x64, 0x64, 0x52,
	0x75, 0x6c, 0x65, 0x12, 0x09, 0x2e, 0x6e, 0x6c, 0x70, 0x2e, 0x52, 0x75, 0x6c, 0x65, 0x1a, 0x11,
	0x2e, 0x6e, 0x6c, 0x70, 0x2e, 0x54, 0x65, 0x78, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
	0x65, 0x22, 0x00, 0x12, 0x33, 0x0a, 0x0a, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x52, 0x75, 0x6c,
	0x65, 0x12, 0x10, 0x2e, 0x6e, 0x6c, 0x70, 0x2e, 0x54, 0x65, 0x78, 0x74, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x1a, 0x11, 0x2e, 0x6e, 0x6c, 0x70, 0x2e, 0x54, 0x65, 0x78, 0x74, 0x52, 0x65,
	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x12, 0x28, 0x0a, 0x07, 0x47, 0x65, 0x74, 0x52,
	0x75, 0x6c, 0x65, 0x12, 0x10, 0x2e, 0x6e, 0x6c, 0x70, 0x2e, 0x54, 0x65, 0x78, 0x74, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x09, 0x2e, 0x6e, 0x6c, 0x70, 0x2e, 0x52, 0x75, 0x6c, 0x65,
	0x22, 0x00, 0x12, 0x2e, 0x0a, 0x0a, 0x47, 0x65, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73,
	0x12, 0x10, 0x2e, 0x6e, 0x6c, 0x70, 0x2e, 0x54, 0x65, 0x78, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x1a, 0x0c, 0x2e, 0x6e, 0x6c, 0x70, 0x2e, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73,
	0x22, 0x00, 0x12, 0x35, 0x0a, 0x0c, 0x52, 0x65, 0x73, 0x65, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68,
	0x65, 0x72, 0x12, 0x10, 0x2e, 0x6e, 0x6c, 0x70, 0x2e, 0x54, 0x65, 0x78, 0x74, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x1a, 0x11, 0x2e, 0x6e, 0x6c, 0x70, 0x2e, 0x54, 0x65, 0x78, 0x74, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x33,
}

var (
	file_nlp_proto_rawDescOnce sync.Once
	file_nlp_proto_rawDescData = file_nlp_proto_rawDesc
)

func file_nlp_proto_rawDescGZIP() []byte {
	file_nlp_proto_rawDescOnce.Do(func() {
		file_nlp_proto_rawDescData = protoimpl.X.CompressGZIP(file_nlp_proto_rawDescData)
	})
	return file_nlp_proto_rawDescData
}

var file_nlp_proto_msgTypes = make([]protoimpl.MessageInfo, 14)
var file_nlp_proto_goTypes = []interface{}{
	(*TextRequest)(nil),           // 0: nlp.TextRequest
	(*TextSimilarityRequest)(nil), // 1: nlp.TextSimilarityRequest
	(*TextResponse)(nil),          // 2: nlp.TextResponse
	(*TextSimilarity)(nil),        // 3: nlp.TextSimilarity
	(*Doc)(nil),                   // 4: nlp.Doc
	(*Ent)(nil),                   // 5: nlp.Ent
	(*Sent)(nil),                  // 6: nlp.Sent
	(*NounChunk)(nil),             // 7: nlp.Noun_chunk
	(*Token)(nil),                 // 8: nlp.Token
	(*ParsedNLPRes)(nil),          // 9: nlp.ParsedNLPRes
	(*Pattern)(nil),               // 10: nlp.Pattern
	(*Rule)(nil),                  // 11: nlp.Rule
	(*Match)(nil),                 // 12: nlp.Match
	(*Matches)(nil),               // 13: nlp.Matches
}
var file_nlp_proto_depIdxs = []int32{
	4,  // 0: nlp.ParsedNLPRes.doc:type_name -> nlp.Doc
	5,  // 1: nlp.ParsedNLPRes.ents:type_name -> nlp.Ent
	6,  // 2: nlp.ParsedNLPRes.sents:type_name -> nlp.Sent
	7,  // 3: nlp.ParsedNLPRes.noun_chunks:type_name -> nlp.Noun_chunk
	8,  // 4: nlp.ParsedNLPRes.tokens:type_name -> nlp.Token
	10, // 5: nlp.Rule.patterns:type_name -> nlp.Pattern
	12, // 6: nlp.Matches.matches:type_name -> nlp.Match
	0,  // 7: nlp.Nlp.LoadModel:input_type -> nlp.TextRequest
	0,  // 8: nlp.Nlp.NlpProcess:input_type -> nlp.TextRequest
	1,  // 9: nlp.Nlp.DocSimilarity:input_type -> nlp.TextSimilarityRequest
	11, // 10: nlp.Nlp.AddRule:input_type -> nlp.Rule
	0,  // 11: nlp.Nlp.RemoveRule:input_type -> nlp.TextRequest
	0,  // 12: nlp.Nlp.GetRule:input_type -> nlp.TextRequest
	0,  // 13: nlp.Nlp.GetMatches:input_type -> nlp.TextRequest
	0,  // 14: nlp.Nlp.ResetMatcher:input_type -> nlp.TextRequest
	2,  // 15: nlp.Nlp.LoadModel:output_type -> nlp.TextResponse
	9,  // 16: nlp.Nlp.NlpProcess:output_type -> nlp.ParsedNLPRes
	3,  // 17: nlp.Nlp.DocSimilarity:output_type -> nlp.TextSimilarity
	2,  // 18: nlp.Nlp.AddRule:output_type -> nlp.TextResponse
	2,  // 19: nlp.Nlp.RemoveRule:output_type -> nlp.TextResponse
	11, // 20: nlp.Nlp.GetRule:output_type -> nlp.Rule
	13, // 21: nlp.Nlp.GetMatches:output_type -> nlp.Matches
	2,  // 22: nlp.Nlp.ResetMatcher:output_type -> nlp.TextResponse
	15, // [15:23] is the sub-list for method output_type
	7,  // [7:15] is the sub-list for method input_type
	7,  // [7:7] is the sub-list for extension type_name
	7,  // [7:7] is the sub-list for extension extendee
	0,  // [0:7] is the sub-list for field type_name
}

func init() { file_nlp_proto_init() }
func file_nlp_proto_init() {
	if File_nlp_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_nlp_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TextRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_nlp_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TextSimilarityRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_nlp_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TextResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_nlp_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TextSimilarity); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_nlp_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Doc); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_nlp_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Ent); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_nlp_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Sent); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_nlp_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NounChunk); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_nlp_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Token); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_nlp_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ParsedNLPRes); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_nlp_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Pattern); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_nlp_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Rule); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_nlp_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Match); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_nlp_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Matches); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_nlp_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   14,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_nlp_proto_goTypes,
		DependencyIndexes: file_nlp_proto_depIdxs,
		MessageInfos:      file_nlp_proto_msgTypes,
	}.Build()
	File_nlp_proto = out.File
	file_nlp_proto_rawDesc = nil
	file_nlp_proto_goTypes = nil
	file_nlp_proto_depIdxs = nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// NlpClient is the client API for Nlp service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type NlpClient interface {
	LoadModel(ctx context.Context, in *TextRequest, opts ...grpc.CallOption) (*TextResponse, error)
	NlpProcess(ctx context.Context, in *TextRequest, opts ...grpc.CallOption) (*ParsedNLPRes, error)
	DocSimilarity(ctx context.Context, in *TextSimilarityRequest, opts ...grpc.CallOption) (*TextSimilarity, error)
	AddRule(ctx context.Context, in *Rule, opts ...grpc.CallOption) (*TextResponse, error)
	RemoveRule(ctx context.Context, in *TextRequest, opts ...grpc.CallOption) (*TextResponse, error)
	GetRule(ctx context.Context, in *TextRequest, opts ...grpc.CallOption) (*Rule, error)
	GetMatches(ctx context.Context, in *TextRequest, opts ...grpc.CallOption) (*Matches, error)
	ResetMatcher(ctx context.Context, in *TextRequest, opts ...grpc.CallOption) (*TextResponse, error)
}

type nlpClient struct {
	cc grpc.ClientConnInterface
}

func NewNlpClient(cc grpc.ClientConnInterface) NlpClient {
	return &nlpClient{cc}
}

func (c *nlpClient) LoadModel(ctx context.Context, in *TextRequest, opts ...grpc.CallOption) (*TextResponse, error) {
	out := new(TextResponse)
	err := c.cc.Invoke(ctx, "/nlp.Nlp/LoadModel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nlpClient) NlpProcess(ctx context.Context, in *TextRequest, opts ...grpc.CallOption) (*ParsedNLPRes, error) {
	out := new(ParsedNLPRes)
	err := c.cc.Invoke(ctx, "/nlp.Nlp/NlpProcess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nlpClient) DocSimilarity(ctx context.Context, in *TextSimilarityRequest, opts ...grpc.CallOption) (*TextSimilarity, error) {
	out := new(TextSimilarity)
	err := c.cc.Invoke(ctx, "/nlp.Nlp/DocSimilarity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nlpClient) AddRule(ctx context.Context, in *Rule, opts ...grpc.CallOption) (*TextResponse, error) {
	out := new(TextResponse)
	err := c.cc.Invoke(ctx, "/nlp.Nlp/AddRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nlpClient) RemoveRule(ctx context.Context, in *TextRequest, opts ...grpc.CallOption) (*TextResponse, error) {
	out := new(TextResponse)
	err := c.cc.Invoke(ctx, "/nlp.Nlp/RemoveRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nlpClient) GetRule(ctx context.Context, in *TextRequest, opts ...grpc.CallOption) (*Rule, error) {
	out := new(Rule)
	err := c.cc.Invoke(ctx, "/nlp.Nlp/GetRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nlpClient) GetMatches(ctx context.Context, in *TextRequest, opts ...grpc.CallOption) (*Matches, error) {
	out := new(Matches)
	err := c.cc.Invoke(ctx, "/nlp.Nlp/GetMatches", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nlpClient) ResetMatcher(ctx context.Context, in *TextRequest, opts ...grpc.CallOption) (*TextResponse, error) {
	out := new(TextResponse)
	err := c.cc.Invoke(ctx, "/nlp.Nlp/ResetMatcher", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NlpServer is the server API for Nlp service.
type NlpServer interface {
	LoadModel(context.Context, *TextRequest) (*TextResponse, error)
	NlpProcess(context.Context, *TextRequest) (*ParsedNLPRes, error)
	DocSimilarity(context.Context, *TextSimilarityRequest) (*TextSimilarity, error)
	AddRule(context.Context, *Rule) (*TextResponse, error)
	RemoveRule(context.Context, *TextRequest) (*TextResponse, error)
	GetRule(context.Context, *TextRequest) (*Rule, error)
	GetMatches(context.Context, *TextRequest) (*Matches, error)
	ResetMatcher(context.Context, *TextRequest) (*TextResponse, error)
}

// UnimplementedNlpServer can be embedded to have forward compatible implementations.
type UnimplementedNlpServer struct {
}

func (*UnimplementedNlpServer) LoadModel(context.Context, *TextRequest) (*TextResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadModel not implemented")
}
func (*UnimplementedNlpServer) NlpProcess(context.Context, *TextRequest) (*ParsedNLPRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NlpProcess not implemented")
}
func (*UnimplementedNlpServer) DocSimilarity(context.Context, *TextSimilarityRequest) (*TextSimilarity, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DocSimilarity not implemented")
}
func (*UnimplementedNlpServer) AddRule(context.Context, *Rule) (*TextResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRule not implemented")
}
func (*UnimplementedNlpServer) RemoveRule(context.Context, *TextRequest) (*TextResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveRule not implemented")
}
func (*UnimplementedNlpServer) GetRule(context.Context, *TextRequest) (*Rule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRule not implemented")
}
func (*UnimplementedNlpServer) GetMatches(context.Context, *TextRequest) (*Matches, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMatches not implemented")
}
func (*UnimplementedNlpServer) ResetMatcher(context.Context, *TextRequest) (*TextResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetMatcher not implemented")
}

func RegisterNlpServer(s *grpc.Server, srv NlpServer) {
	s.RegisterService(&_Nlp_serviceDesc, srv)
}

func _Nlp_LoadModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NlpServer).LoadModel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nlp.Nlp/LoadModel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NlpServer).LoadModel(ctx, req.(*TextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nlp_NlpProcess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NlpServer).NlpProcess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nlp.Nlp/NlpProcess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NlpServer).NlpProcess(ctx, req.(*TextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nlp_DocSimilarity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TextSimilarityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NlpServer).DocSimilarity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nlp.Nlp/DocSimilarity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NlpServer).DocSimilarity(ctx, req.(*TextSimilarityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nlp_AddRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Rule)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NlpServer).AddRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nlp.Nlp/AddRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NlpServer).AddRule(ctx, req.(*Rule))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nlp_RemoveRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NlpServer).RemoveRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nlp.Nlp/RemoveRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NlpServer).RemoveRule(ctx, req.(*TextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nlp_GetRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NlpServer).GetRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nlp.Nlp/GetRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NlpServer).GetRule(ctx, req.(*TextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nlp_GetMatches_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NlpServer).GetMatches(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nlp.Nlp/GetMatches",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NlpServer).GetMatches(ctx, req.(*TextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nlp_ResetMatcher_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TextRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NlpServer).ResetMatcher(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nlp.Nlp/ResetMatcher",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NlpServer).ResetMatcher(ctx, req.(*TextRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Nlp_serviceDesc = grpc.ServiceDesc{
	ServiceName: "nlp.Nlp",
	HandlerType: (*NlpServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LoadModel",
			Handler:    _Nlp_LoadModel_Handler,
		},
		{
			MethodName: "NlpProcess",
			Handler:    _Nlp_NlpProcess_Handler,
		},
		{
			MethodName: "DocSimilarity",
			Handler:    _Nlp_DocSimilarity_Handler,
		},
		{
			MethodName: "AddRule",
			Handler:    _Nlp_AddRule_Handler,
		},
		{
			MethodName: "RemoveRule",
			Handler:    _Nlp_RemoveRule_Handler,
		},
		{
			MethodName: "GetRule",
			Handler:    _Nlp_GetRule_Handler,
		},
		{
			MethodName: "GetMatches",
			Handler:    _Nlp_GetMatches_Handler,
		},
		{
			MethodName: "ResetMatcher",
			Handler:    _Nlp_ResetMatcher_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nlp.proto",
}
